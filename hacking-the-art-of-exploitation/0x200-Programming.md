#### 0x200 Programming

```Assembly language``` ----Assembler----&rightarrow; ```Machine language```

```High-level language``` ----Compiler----&rightarrow; ```Machine language```

###### Pseudo-code

- English like 
- Arranged with a general structure 
- Similar to a high-level language

###### Control Structures

- If-Then-Else

```
If (condition) then 
{	Set of instructions to execute if the condition is met;} 
Else 
{	Set of instruction to execute if the condition is not met;}
```

- While/Until Loops

```
While (you are hungry) 
{	Find some food;	Eat the food; 
}
```

```
Until (you are not hungry) 
{	Find some food;	Eat the food; 
}
```

- For Loops

```
for (i=0; i<5; i++)
{
	Drive straight for 1 mile;
}
```

###### More Fundamental Programming Concepts

- Variables
	- Variables
	- Constants

```
int a, b; 
float k; 
char z;
```

```
int a = 13, b; 
float k;char z = 'A';
k = 3.14; 
z = 'w';b = a + 5;
```

- Arithmetic Operators

Operation | Symbol | Example
----------|--------|---------Addition 	| + | b = a + 5
Subtraction | - | b = a - 5
Multiplication | * | b = a * 5
Division | / | b = a / 5Modulo reduction | % | b = a % 5Full Expression | Shorthand | Explanation
----------------|-----------|-----------------
i = i + 1 | i++ or ++i | Add 1 to the variable
i = i - 1 | i-- or --i | Subtract 1 from the variable

Full Expression | Shorthand | Explanation
----------------|-----------|-----------------
i = i + 12 | i+=12 | Add some value to the variable.
i = i - 12 | i-=12 | Subtract some value from the variable.
i = i * 12 | i*=12 | Multiply some value by the variable.
i = i / 12 | i/=12 | Divide some value from the variable.

- Comparison Operators

Condition | Symbol | Example
----------|--------|-------------
Less than | < | (a<b)
Greater than | > | (a>b)
Less than or equal to | <= | (a<=b)
Greater than or equal to | >= | (a>=b)
Equal to | == | (a==b)
Not equal to | != | (a!=b)

Logic | Symbol | Example
------|--------|-------------
OR | ```||``` | ((a < b) || (a < c))
AND | ```&&``` | ((a < b) && !(a < c))

- Functions

```
int factorial(int x) 
{	int i;	for(i=1; i < x; i++)    	x *= i;  	return x;}```

```
int a = 5, b;b = factorial(a);
```

```
int factorial(int);
```

###### Getting your hands dirty

- Location of header files

```/usr/include```

- ```GCC``` Version

```sh
root@kali:~/hacking/booksrc# gcc --version
gcc (Debian 6.3.0-12) 6.3.0 20170406
Copyright (C) 2016 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

root@kali:~/hacking/booksrc#
```

- Write and Compile ```C``` programs

```sh
root@kali:~/hacking/booksrc# cat firstprog.c
#include <stdio.h>

int main()
{
  int i;
  for(i=0; i < 10; i++)
  {
    printf("Hello World!\n");
  }
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc firstprog.c -o firstprog
```

```sh
root@kali:~/hacking/booksrc# file firstprog
firstprog: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=84d59dc5f956badc162523dcaa2dc18e0fe5be5a, not stripped
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# ./firstprog
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
root@kali:~/hacking/booksrc#
```

- Machine code of the ```main()``` function

	- AT&T

	```sh
	root@kali:~/hacking/booksrc# objdump -D firstprog | grep -A 36 main.:
	00000590 <main>:
	 590:	8d 4c 24 04          	lea    0x4(%esp),%ecx
	 594:	83 e4 f0             	and    $0xfffffff0,%esp
	 597:	ff 71 fc             	pushl  -0x4(%ecx)
	 59a:	55                   	push   %ebp
	 59b:	89 e5                	mov    %esp,%ebp
	 59d:	53                   	push   %ebx
	 59e:	51                   	push   %ecx
	 59f:	83 ec 10             	sub    $0x10,%esp
	 5a2:	e8 b9 fe ff ff       	call   460 <__x86.get_pc_thunk.bx>
	 5a7:	81 c3 59 1a 00 00    	add    $0x1a59,%ebx
	 5ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	 5b4:	eb 16                	jmp    5cc <main+0x3c>
	 5b6:	83 ec 0c             	sub    $0xc,%esp
	 5b9:	8d 83 70 e6 ff ff    	lea    -0x1990(%ebx),%eax
	 5bf:	50                   	push   %eax
	 5c0:	e8 2b fe ff ff       	call   3f0 <puts@plt>
	 5c5:	83 c4 10             	add    $0x10,%esp
	 5c8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
	 5cc:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
	 5d0:	7e e4                	jle    5b6 <main+0x26>
	 5d2:	b8 00 00 00 00       	mov    $0x0,%eax
	 5d7:	8d 65 f8             	lea    -0x8(%ebp),%esp
	 5da:	59                   	pop    %ecx
	 5db:	5b                   	pop    %ebx
	 5dc:	5d                   	pop    %ebp
	 5dd:	8d 61 fc             	lea    -0x4(%ecx),%esp
	 5e0:	c3                   	ret
	 5e1:	66 90                	xchg   %ax,%ax
	 5e3:	66 90                	xchg   %ax,%ax
	 5e5:	66 90                	xchg   %ax,%ax
	 5e7:	66 90                	xchg   %ax,%ax
	 5e9:	66 90                	xchg   %ax,%ax
	 5eb:	66 90                	xchg   %ax,%ax
	 5ed:	66 90                	xchg   %ax,%ax
	 5ef:	90                   	nop
	
	root@kali:~/hacking/booksrc#
	```

	- Intel

	```sh
	root@kali:~/hacking/booksrc# objdump -D firstprog -M intel | grep -A 36 main.:
	00000590 <main>:
	 590:	8d 4c 24 04          	lea    ecx,[esp+0x4]
	 594:	83 e4 f0             	and    esp,0xfffffff0
	 597:	ff 71 fc             	push   DWORD PTR [ecx-0x4]
	 59a:	55                   	push   ebp
	 59b:	89 e5                	mov    ebp,esp
	 59d:	53                   	push   ebx
	 59e:	51                   	push   ecx
	 59f:	83 ec 10             	sub    esp,0x10
	 5a2:	e8 b9 fe ff ff       	call   460 <__x86.get_pc_thunk.bx>
	 5a7:	81 c3 59 1a 00 00    	add    ebx,0x1a59
	 5ad:	c7 45 f4 00 00 00 00 	mov    DWORD PTR [ebp-0xc],0x0
	 5b4:	eb 16                	jmp    5cc <main+0x3c>
	 5b6:	83 ec 0c             	sub    esp,0xc
	 5b9:	8d 83 70 e6 ff ff    	lea    eax,[ebx-0x1990]
	 5bf:	50                   	push   eax
	 5c0:	e8 2b fe ff ff       	call   3f0 <puts@plt>
	 5c5:	83 c4 10             	add    esp,0x10
	 5c8:	83 45 f4 01          	add    DWORD PTR [ebp-0xc],0x1
	 5cc:	83 7d f4 09          	cmp    DWORD PTR [ebp-0xc],0x9
	 5d0:	7e e4                	jle    5b6 <main+0x26>
	 5d2:	b8 00 00 00 00       	mov    eax,0x0
	 5d7:	8d 65 f8             	lea    esp,[ebp-0x8]
	 5da:	59                   	pop    ecx
	 5db:	5b                   	pop    ebx
	 5dc:	5d                   	pop    ebp
	 5dd:	8d 61 fc             	lea    esp,[ecx-0x4]
	 5e0:	c3                   	ret
	 5e1:	66 90                	xchg   ax,ax
	 5e3:	66 90                	xchg   ax,ax
	 5e5:	66 90                	xchg   ax,ax
	 5e7:	66 90                	xchg   ax,ax
	 5e9:	66 90                	xchg   ax,ax
	 5eb:	66 90                	xchg   ax,ax
	 5ed:	66 90                	xchg   ax,ax
	 5ef:	90                   	nop
	
	root@kali:~/hacking/booksrc#
	```
	
###### The x86 Processor

- Registers
	- Internal Variables

General Purpose Register | Use
-------------------------|--------
EAX | Accumulator
EBX | Base
ECX | Counter
EDX | Data

Pointers & Indexes | Use
-------------------|------
ESP | Stack Pointer
EBP | Base Pointer
ESI | Source Index
EDI | Destination Index

```EIP```
	- Instruction Pointer
	- Points to the current instruction the processor is reading

[```EFLAGS```](http://www.c-jump.com/CIS77/ASM/Instructions/I77_0070_eflags_bits.htm)
	- Bit flags that are used for comparisons and memory segmentation


- Debugger
	- Step through the compiled program
	- Examine program memory
	- View processor registers

- GDB

```sh
root@kali:~/hacking/booksrc# gdb ./firstprog -q
Reading symbols from ./firstprog...(no debugging symbols found)...done.
(gdb) break main
Breakpoint 1 at 0x59f
(gdb) run
Starting program: /root/hacking/booksrc/firstprog

Breakpoint 1, 0x8000059f in main ()
(gdb) info registers
eax            0xb7fb2dbc	-1208275524
ecx            0xbffff680	-1073744256
edx            0xbffff6a4	-1073744220
ebx            0x0	0
esp            0xbffff660	0xbffff660
ebp            0xbffff668	0xbffff668
esi            0x1	1
edi            0xb7fb1000	-1208283136
eip            0x8000059f	0x8000059f <main+15>
eflags         0x282	[ SF IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb) quit
A debugging session is active.

	Inferior 1 [process 1605] will be killed.

Quit anyway? (y or n) y
root@kali:~/hacking/booksrc#
```

###### Assembly Language

- ```GDB``` init file to use ```Intel``` syntax

```sh
root@kali:~/hacking/booksrc# gdb -q
(gdb) set disassembly-flavor intel
(gdb) quit
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# echo "set disassembly-flavor intel" > ~/.gdbinit
root@kali:~/hacking/booksrc# cat ~/.gdbinit
set disassembly-flavor intel
root@kali:~/hacking/booksrc#
```

- Intel Syntax

```
operation <destination>, <source>
```

```DWORD``` - 4 bytes

- Compile with debug information

```sh
root@kali:~/hacking/booksrc# gcc firstprog.c -o firstprog_debug -g
```

```sh
root@kali:~/hacking/booksrc# file firstprog_debug
firstprog_debug: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=f9594a9b7afa7598a838fee6af6531982c357267, not stripped
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gdb ./firstprog_debug -q
Reading symbols from ./firstprog_debug...done.
(gdb) list
1	#include <stdio.h>
2
3	int main()
4	{
5	  int i;
6	  for(i=0; i < 10; i++)
7	  {
8	    printf("Hello World!\n");
9	  }
10	}
(gdb) disassemble main
Dump of assembler code for function main:
   0x00000590 <+0>:	lea    ecx,[esp+0x4]
   0x00000594 <+4>:	and    esp,0xfffffff0
   0x00000597 <+7>:	push   DWORD PTR [ecx-0x4]
   0x0000059a <+10>:	push   ebp
   0x0000059b <+11>:	mov    ebp,esp
   0x0000059d <+13>:	push   ebx
   0x0000059e <+14>:	push   ecx
   0x0000059f <+15>:	sub    esp,0x10
   0x000005a2 <+18>:	call   0x460 <__x86.get_pc_thunk.bx>
   0x000005a7 <+23>:	add    ebx,0x1a59
   0x000005ad <+29>:	mov    DWORD PTR [ebp-0xc],0x0
   0x000005b4 <+36>:	jmp    0x5cc <main+60>
   0x000005b6 <+38>:	sub    esp,0xc
   0x000005b9 <+41>:	lea    eax,[ebx-0x1990]
   0x000005bf <+47>:	push   eax
   0x000005c0 <+48>:	call   0x3f0 <puts@plt>
   0x000005c5 <+53>:	add    esp,0x10
   0x000005c8 <+56>:	add    DWORD PTR [ebp-0xc],0x1
   0x000005cc <+60>:	cmp    DWORD PTR [ebp-0xc],0x9
   0x000005d0 <+64>:	jle    0x5b6 <main+38>
   0x000005d2 <+66>:	mov    eax,0x0
   0x000005d7 <+71>:	lea    esp,[ebp-0x8]
   0x000005da <+74>:	pop    ecx
   0x000005db <+75>:	pop    ebx
   0x000005dc <+76>:	pop    ebp
   0x000005dd <+77>:	lea    esp,[ecx-0x4]
   0x000005e0 <+80>:	ret
End of assembler dump.
(gdb) break main
Breakpoint 1 at 0x5ad: file firstprog.c, line 6.
(gdb) run
Starting program: /root/hacking/booksrc/firstprog_debug

Breakpoint 1, main () at firstprog.c:6
6	  for(i=0; i < 10; i++)
(gdb) info registers eip
eip            0x800005ad	0x800005ad <main+29>
(gdb)
```

EIP

```sh
   0x000005ad <+29>:	mov    DWORD PTR [ebp-0xc],0x0
```

Function Prolog

```sh
   0x00000590 <+0>:		lea    ecx,[esp+0x4]
   0x00000594 <+4>:		and    esp,0xfffffff0
   0x00000597 <+7>:		push   DWORD PTR [ecx-0x4]
   0x0000059a <+10>:	push   ebp
   0x0000059b <+11>:	mov    ebp,esp
   0x0000059d <+13>:	push   ebx
   0x0000059e <+14>:	push   ecx
   0x0000059f <+15>:	sub    esp,0x10
   0x000005a2 <+18>:	call   0x460 <__x86.get_pc_thunk.bx>
   0x000005a7 <+23>:	add    ebx,0x1a59
```

- Examine - ```x```
	- 2 arguments
		- Location of memory to examine
		- How to display the memory
			- display is preceded by a count of how many items to examine

Display format Shorthand | Display format
-------------------------|------------------
o | Octal
x | hexadecimal
u | unsigned, standard base-10 decimal
t | binary
c | character
s | entire string

```sh
(gdb) i r eip
eip            0x800005ad	0x800005ad <main+29>
(gdb) x/o 0x800005ad
0x800005ad <main+29>:	075042707
(gdb) x/x 0x800005ad
0x800005ad <main+29>:	0x00f445c7
(gdb) x/u 0x800005ad
0x800005ad <main+29>:	16008647
(gdb) x/t 0x800005ad
0x800005ad <main+29>:	00000000111101000100010111000111
(gdb)
```

```sh
(gdb) x/2x $eip
0x800005ad <main+29>:	0x00f445c7	0xeb000000
(gdb) x/12x $eip
0x800005ad <main+29>:	0x00f445c7	0xeb000000	0x0cec8316	0xe670838d
0x800005bd <main+45>:	0xe850ffff	0xfffffe2b	0x8310c483	0x8301f445
0x800005cd <main+61>:	0x7e09f47d	0x0000b8e4	0x658d0000	0x5d5b59f8
(gdb)
```

Size Alphabet | Size
--------------|--------
b | 1 byte
h | Halfword - 2 bytes
w | Word - 4 bytes
g | Giant - 8 bytes

_**Sometimes ```DWORD``` and ```WORD``` both are 4 bytes**_


```sh
(gdb) x/8xb $eip
0x800005ad <main+29>:	0xc7	0x45	0xf4	0x00	0x00	0x00	0x00	0xeb
(gdb) x/8xh $eip
0x800005ad <main+29>:	0x45c7	0x00f4	0x0000	0xeb00	0x8316	0x0cec	0x838d	0xe670
(gdb) x/8xw $eip
0x800005ad <main+29>:	0x00f445c7	0xeb000000	0x0cec8316	0xe670838d
0x800005bd <main+45>:	0xe850ffff	0xfffffe2b	0x8310c483	0x8301f445
(gdb) x/8xg $eip
0x800005ad <main+29>:	0xeb00000000f445c7	0xe670838d0cec8316
0x800005bd <main+45>:	0xfffffe2be850ffff	0x8301f4458310c483
0x800005cd <main+61>:	0x0000b8e47e09f47d	0x5d5b59f8658d0000
0x800005dd <main+77>:	0x90669066c3fc618d	0x9066906690669066
(gdb)
```

Examine instructions - ```i```

```sh
root@kali:~/hacking/booksrc# gdb ./firstprog_debug -q
Reading symbols from ./firstprog_debug...done.
(gdb) break main
Breakpoint 1 at 0x5ad: file firstprog.c, line 6.
(gdb) run
Starting program: /root/hacking/booksrc/firstprog_debug

Breakpoint 1, main () at firstprog.c:6
6	  for(i=0; i < 10; i++)
(gdb) i r $eip
eip            0x800005ad	0x800005ad <main+29>
(gdb) x/i $eip
=> 0x800005ad <main+29>:	mov    DWORD PTR [ebp-0xc],0x0
(gdb) x/3i $eip
=> 0x800005ad <main+29>:	mov    DWORD PTR [ebp-0xc],0x0
   0x800005b4 <main+36>:	jmp    0x800005cc <main+60>
   0x800005b6 <main+38>:	sub    esp,0xc
(gdb) x/7xb $eip
0x800005ad <main+29>:	0xc7	0x45	0xf4	0x00	0x00	0x00	0x00
(gdb) x/i $eip
=> 0x800005ad <main+29>:	mov    DWORD PTR [ebp-0xc],0x0
(gdb)
```

```objdump``` output

```sh
root@kali:~/hacking/booksrc# objdump -D firstprog -M intel | grep -A 36 main.:
<---snip--->
  5ad:	c7 45 f4 00 00 00 00 	mov    DWORD PTR [ebp-0xc],0x0
<---snip--->
```

Examining the ```ebp-0xc```

```sh
(gdb) i r ebp
ebp            0xbffff658	0xbffff658
(gdb) x/4xb $ebp-0xc
0xbffff64c:	0x11	0x06	0x00	0x80
(gdb) x/12xb $ebp-0xc
0xbffff64c:	0x11	0x06	0x00	0x80	0x70	0xf6	0xff	0xbf
0xbffff654:	0x00	0x00	0x00	0x00
(gdb) print $ebp-0xc
$1 = (void *) 0xbffff64c
(gdb) x/4xb $1
0xbffff64c:	0x11	0x06	0x00	0x80
(gdb) x/xw $1
0xbffff64c:	0x80000611
```

Single Step and check the value of ```ebp-0xc```

```sh
(gdb) nexti
0x800005b4	6	  for(i=0; i < 10; i++)
(gdb) x/xw $1
0xbffff64c:	0x00000000
(gdb) x/4xb $1
0xbffff64c:	0x00	0x00	0x00	0x00
(gdb) x/dw $1
0xbffff64c:	0
(gdb) i r eip
eip            0x800005b4	0x800005b4 <main+36>
(gdb) x/i $eip
=> 0x800005b4 <main+36>:	jmp    0x800005cc <main+60>
(gdb)
```

Refer to page ```32``` - ```37``` of the book - Very detailed and nice explanation

###### Back to Basics

- Strings

Refer to page ```38``` - ```41``` of the book

```sh
root@kali:~/hacking/booksrc# cat char_array.c
#include <stdio.h>
int main()
{
  char str_a[20];
  str_a[0]  = 'H';
  str_a[1]  = 'e';
  str_a[2]  = 'l';
  str_a[3]  = 'l';
  str_a[4]  = 'o';
  str_a[5]  = ',';
  str_a[6]  = ' ';
  str_a[7]  = 'w';
  str_a[8]  = 'o';
  str_a[9]  = 'r';
  str_a[10]  = 'l';
  str_a[11] = 'd';
  str_a[12] = '!';
  str_a[13] = '\n';
  str_a[14] = 0;
  printf(str_a);
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc char_array.c -o char_array
```

```sh
root@kali:~/hacking/booksrc# ./char_array
Hello, world!
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# cat char_array2.c
#include <stdio.h>
#include <string.h>

int main() {
   char str_a[20];

   strcpy(str_a, "Hello World!\n");
   printf(str_a);
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc char_array2.c -o char_array2
```

```sh
root@kali:~/hacking/booksrc# ./char_array2
Hello World!
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc char_array2.c -o char_array2_debug -g
```

```sh
root@kali:~/hacking/booksrc# ./char_array2_debug
Hello World!
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gdb ./char_array2_debug -q
Reading symbols from ./char_array2_debug...done.
(gdb) list
1	#include <stdio.h>
2	#include <string.h>
3
4	int main() {
5	   char str_a[20];
6
7	   strcpy(str_a, "Hello World!\n");
8	   printf(str_a);
9	}
(gdb) break 6
Breakpoint 1 at 0x5bd: file char_array2.c, line 6.
(gdb) break strcpy
Function "strcpy" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 2 (strcpy) pending.
(gdb) break 8
Breakpoint 3 at 0x5da: file char_array2.c, line 8.
(gdb) info breakpoints
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x000005bd in main at char_array2.c:6
2       breakpoint     keep y   <PENDING>  strcpy
3       breakpoint     keep y   0x000005da in main at char_array2.c:8
(gdb) run
Starting program: /root/hacking/booksrc/char_array2_debug

Breakpoint 1, main () at char_array2.c:7
7	   strcpy(str_a, "Hello World!\n");
(gdb) i r eip
eip            0x800005bd	0x800005bd <main+29>
(gdb) x/5i $eip
=> 0x800005bd <main+29>:	lea    eax,[ebp-0x1c]
   0x800005c0 <main+32>:	mov    DWORD PTR [eax],0x6c6c6548
   0x800005c6 <main+38>:	mov    DWORD PTR [eax+0x4],0x6f57206f
   0x800005cd <main+45>:	mov    DWORD PTR [eax+0x8],0x21646c72
   0x800005d4 <main+52>:	mov    WORD PTR [eax+0xc],0xa
(gdb) continue
Continuing.

Breakpoint 3, main () at char_array2.c:8
8	   printf(str_a);
(gdb) i r eip
eip            0x800005da	0x800005da <main+58>
(gdb) x/5i $eip
=> 0x800005da <main+58>:	sub    esp,0xc
   0x800005dd <main+61>:	lea    eax,[ebp-0x1c]
   0x800005e0 <main+64>:	push   eax
   0x800005e1 <main+65>:	mov    ebx,edx
   0x800005e3 <main+67>:	call   0x80000400 <printf@plt>
(gdb) c
Continuing.
Hello World!
[Inferior 1 (process 31559) exited normally]
(gdb) q
root@kali:~/hacking/booksrc#
```

```bt``` - backtrace the stack

```sh
root@kali:~/hacking/booksrc# gdb ./char_array2_debug -q
Reading symbols from ./char_array2_debug...done.
(gdb) list
1	#include <stdio.h>
2	#include <string.h>
3
4	int main() {
5	   char str_a[20];
6
7	   strcpy(str_a, "Hello World!\n");
8	   printf(str_a);
9	}
(gdb) b 7
Breakpoint 1 at 0x5bd: file char_array2.c, line 7.
(gdb) b strcpy
Function "strcpy" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 2 (strcpy) pending.
(gdb) b 8
Breakpoint 3 at 0x5da: file char_array2.c, line 8.
(gdb) info breakpoints
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x000005bd in main at char_array2.c:7
2       breakpoint     keep y   <PENDING>  strcpy
3       breakpoint     keep y   0x000005da in main at char_array2.c:8
(gdb) run
Starting program: /root/hacking/booksrc/char_array2_debug

Breakpoint 1, main () at char_array2.c:7
7	   strcpy(str_a, "Hello World!\n");
(gdb) bt
#0  main () at char_array2.c:7
(gdb) c
Continuing.

Breakpoint 3, main () at char_array2.c:8
8	   printf(str_a);
(gdb) bt
#0  main () at char_array2.c:8
(gdb) c
Continuing.
Hello World!
[Inferior 1 (process 31599) exited normally]
(gdb)
```

- Signed, Unsigned, Long, Short

Signed | Representation
-------|-------------
+ve Number | Normal
-ve Number | Two's Complement

Two's Complement Process

+ve Number in binary &rightarrow; invert all bits &rightarrow; add 1

```sh
#include <stdio.h>

int main() {
	printf("The 'int' data type is\t\t %d bytes\n", sizeof(int));
	printf("The 'unsigned int' data type is\t %d bytes\n", sizeof(unsigned int));
	printf("The 'short int' data type is\t %d bytes\n", sizeof(short int));
	printf("The 'long int' data type is\t %d bytes\n", sizeof(long int));
	printf("The 'long long int' data type is %d bytes\n", sizeof(long long int));
	printf("The 'float' data type is\t %d bytes\n", sizeof(float));
	printf("The 'char' data type is\t\t %d bytes\n", sizeof(char));
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc datatype_sizes.c -o datatype_sizes
```

```sh
root@kali:~/hacking/booksrc# ./datatype_sizes
The 'int' data type is		 4 bytes
The 'unsigned int' data type is	 4 bytes
The 'short int' data type is	 2 bytes
The 'long int' data type is	 4 bytes
The 'long long int' data type is 8 bytes
The 'float' data type is	 4 bytes
The 'char' data type is		 1 bytes
root@kali:~/hacking/booksrc#
```

- Pointer

```sh
root@kali:~/hacking/booksrc# cat pointer.c
#include <stdio.h>
#include <string.h>

int main() {
   char str_a[20];  // a 20 element character array
   char *pointer;   // a pointer, meant for a character array
   char *pointer2;  // and yet another one

   strcpy(str_a, "Hello World\n");
   pointer = str_a; // set the first pointer to the start of the array
   printf(pointer);

   pointer2 = pointer + 2; // set the second one 2 bytes further in
   printf(pointer2);       // print it
   strcpy(pointer2, "y you guys!\n"); // copy into that spot
   printf(pointer);        // print again
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc pointer.c -o pointer
```

```sh
root@kali:~/hacking/booksrc# ./pointer
Hello World
llo World
Hey you guys!
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gdb ./pointer_debug -q
Reading symbols from ./pointer_debug...done.
(gdb) list
1	#include <stdio.h>
2	#include <string.h>
3
4	int main() {
5	   char str_a[20];  // a 20 element character array
6	   char *pointer;   // a pointer, meant for a character array
7	   char *pointer2;  // and yet another one
8
9	   strcpy(str_a, "Hello World\n");
10	   pointer = str_a; // set the first pointer to the start of the array
(gdb)
11	   printf(pointer);
12
13	   pointer2 = pointer + 2; // set the second one 2 bytes further in
14	   printf(pointer2);       // print it
15	   strcpy(pointer2, "y you guys!\n"); // copy into that spot
16	   printf(pointer);        // print again
17	}
(gdb) break 11
Breakpoint 1 at 0x5de: file pointer.c, line 11.
(gdb) run
Starting program: /root/hacking/booksrc/pointer_debug

Breakpoint 1, main () at pointer.c:11
11	   printf(pointer);
(gdb) x/xw pointer
0xbffff624:	0x6c6c6548
(gdb) x/s pointer
0xbffff624:	"Hello World\n"
(gdb)
```

Pointer Operations | Descriptions
-------------------|--------------------------------------
&pointer | Return the address of the ```pointer``` variable
pointer  | Value (usually an address as pointer variables store an address)
*pointer | Value stored in the address stored at ```pointer```(Dereference operator)

![Image of Pointer](images/2/1.jpeg)

```var1``` stores the value ```0x80000032``` and has the address ```0x80000024```. ```0x80000032``` address has the value ```50```

```
var1 = 0x80000032
*var1 = 50
&var1 = 0x80000024
```

```sh
(gdb) x/xw &pointer
0xbffff63c:	0xbffff624
(gdb) print &pointer
$1 = (char **) 0xbffff63c
(gdb) print pointer
$2 = 0xbffff624 "Hello World\n"
(gdb)
```

```sh
root@kali:~/hacking/booksrc# cat addressof.c
#include <stdio.h>

int main() {
	int int_var = 5;
	int *int_ptr;

	int_ptr = &int_var; // put the address of int_var into int_ptr
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc addressof.c -o addressof
```

```sh
root@kali:~/hacking/booksrc# ./addressof
```

```sh
root@kali:~/hacking/booksrc# gcc addressof.c -o addressof_debug -g
```

```sh
root@kali:~/hacking/booksrc# ./addressof_debug
```

```sh
root@kali:~/hacking/booksrc# gdb ./addressof_debug -q
Reading symbols from ./addressof_debug...done.
(gdb) list
1	#include <stdio.h>
2
3	int main() {
4		int int_var = 5;
5		int *int_ptr;
6
7		int_ptr = &int_var; // put the address of int_var into int_ptr
8	}
(gdb) break 8
Breakpoint 1 at 0x582: file addressof.c, line 8.
(gdb) run
Starting program: /root/hacking/booksrc/addressof_debug

Breakpoint 1, main () at addressof.c:8
8	}
(gdb) print int_var
$1 = 5
(gdb) print &int_var
$2 = (int *) 0xbffff650
(gdb) print int_ptr
$3 = (int *) 0xbffff650
(gdb) print &int_ptr
$4 = (int **) 0xbffff654
(gdb) print *int_ptr
$5 = 5
(gdb)
```

```sh
root@kali:~/hacking/booksrc# cat addressof2.c
#include <stdio.h>

int main() {
   int int_var = 5;
   int *int_ptr;

   int_ptr = &int_var; // put the address of int_var into int_ptr

   printf("int_ptr = 0x%08x\n", int_ptr);
   printf("&int_ptr = 0x%08x\n", &int_ptr);
   printf("*int_ptr = 0x%08x\n\n", *int_ptr);

   printf("int_var is located at 0x%08x and contains %d\n", &int_var, int_var);
   printf("int_ptr is located at 0x%08x, contains 0x%08x, and points to %d\n\n",
      &int_ptr, int_ptr, *int_ptr);
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc addressof2.c -o addressof2
```

```sh
root@kali:~/hacking/booksrc# ./addressof2
int_ptr = 0xbf94491c
&int_ptr = 0xbf944918
*int_ptr = 0x00000005

int_var is located at 0xbf94491c and contains 5
int_ptr is located at 0xbf944918, contains 0xbf94491c, and points to 5

root@kali:~/hacking/booksrc#
```

- Format Strings

	- Escape sequences are called format parameters
	- Format parameters that expect values

		Parameter | Output Type
		----------|-------------
		%d | Decimal
		%u | Unsigned decimal
		%x | Hexadecimal

	- Format parameters that expect pointers

		Parameter | Output Type
		----------|-------------
		%s | String
		%n | Number of bytes written so far

[```%n```](http://www.geeksforgeeks.org/g-fact-31/) writes data. It expects a memory address and it writes the number of bytes that have been written so far.

It prints the number of characters that have been printed by ```printf()``` before the occurrence of ```%n```.


```sh
root@kali:~/hacking/booksrc# cat format_n.c
#include<stdio.h>

int main()
{
  int c;
  printf("geeks for %ngeeks ", &c);
  printf("%d", c);
  getchar();
  return 0;
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc format_n.c -o format_n
```

```sh
root@kali:~/hacking/booksrc# ./format_n
geeks for geeks 10
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# cat fmt_strings.c
#include <stdio.h>

int main() {
   char string[10];
   int A = -73;
   unsigned int B = 31337;

   strcpy(string, "sample");

   // Example of printing with different format string
   printf("[A] Dec: %d, Hex: %x, Unsigned: %u\n", A, A, A);
   printf("[B] Dec: %d, Hex: %x, Unsigned: %u\n", B, B, B);
   printf("[field width on B] 3: '%3u', 10: '%10u', '%08u'\n", B, B, B);
   printf("[string] %s  Address %08x\n", string, string);

   // Example of unary address operator (dereferencing) and a %x format string
   printf("variable A is at address: %08x\n", &A);
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc fmt_strings.c -o fmt_strings
fmt_strings.c: In function ‘main’:
fmt_strings.c:8:4: warning: implicit declaration of function ‘strcpy’ [-Wimplicit-function-declaration]
    strcpy(string, "sample");
    ^~~~~~
fmt_strings.c:8:4: warning: incompatible implicit declaration of built-in function ‘strcpy’
fmt_strings.c:8:4: note: include ‘<string.h>’ or provide a declaration of ‘strcpy’
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# ./fmt_strings
[A] Dec: -73, Hex: ffffffb7, Unsigned: 4294967223
[B] Dec: 31337, Hex: 7a69, Unsigned: 31337
[field width on B] 3: '31337', 10: '     31337', '00031337'
[string] sample  Address bff8eda2
variable A is at address: bff8ed9c
root@kali:~/hacking/booksrc#
```

```scanf()``` function expects its arguments to be pointers

```sh
root@kali:~/hacking/booksrc# cat input.c
#include <stdio.h>
#include <string.h>

int main() {
   char message[10];
   int count, i;

   strcpy(message, "Hello, world!");

   printf("Repeat how many times? ");
   scanf("%d", &count);

   for(i=0; i < count; i++)
      printf("%3d - %s\n", i, message);
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc input.c -o input
```

```sh
root@kali:~/hacking/booksrc# ./input
Repeat how many times? 6
  0 - Hello, wor
  1 - Hello, wor
  2 - Hello, wor
  3 - Hello, wor
  4 - Hello, wor
  5 - Hello, wor
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# ./input
Repeat how many times? 12
  0 - Hello, wor
  1 - Hello, wor
  2 - Hello, wor
  3 - Hello, wor
  4 - Hello, wor
  5 - Hello, wor
  6 - Hello, wor
  7 - Hello, wor
  8 - Hello, wor
  9 - Hello, wor
 10 - Hello, wor

 11 - Hello, wor

root@kali:~/hacking/booksrc#
```

- Typecasting

```(typecast_data_type) variable```

```sh
root@kali:~/hacking/booksrc# cat typecasting.c
#include <stdio.h>

int main() {
   int a, b;
   float c, d;

   a = 13;
   b = 5;

   c = a / b;                  // divide using integers
   d = (float) a / (float) b;  // divide integers typecast as floats

   printf("[integers]\t a = %d\t b = %d\n", a, b);
   printf("[floats]\t c = %f\t d = %f\n", c, d);
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc typecasting.c -o typecasting
```

```sh
root@kali:~/hacking/booksrc# ./typecasting
[integers]	 a = 13	 b = 5
[floats]	 c = 2.000000	 d = 2.600000
root@kali:~/hacking/booksrc#
```

```C``` compiler demands a data type for each pointer.

Integer pointer should only point to integer data.

Character pointer should only point to character data.

```%p``` same as ```0x%08x```

```sh
root@kali:~/hacking/booksrc# cat pointer_types.c
#include <stdio.h>

int main() {
	int i;

	char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
	int int_array[5] = {1, 2, 3, 4, 5};

	char *char_pointer;
	int *int_pointer;

	char_pointer = char_array;
	int_pointer = int_array;

	for(i=0; i < 5; i++) { // iterate through the int array with the int_pointer
		printf("[integer pointer] points to %p, which contains the integer %d\n",
            int_pointer, *int_pointer);
		int_pointer = int_pointer + 1;
	}

	for(i=0; i < 5; i++) { // iterate through the char array with the char_pointer
		printf("[char pointer] points to %p, which contains the char '%c'\n",
            char_pointer, *char_pointer);
		char_pointer = char_pointer + 1;
	}
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc pointer_types.c -o pointer_types
```

```sh
root@kali:~/hacking/booksrc# ./pointer_types
[integer pointer] points to 0xbf9e8488, which contains the integer 1
[integer pointer] points to 0xbf9e848c, which contains the integer 2
[integer pointer] points to 0xbf9e8490, which contains the integer 3
[integer pointer] points to 0xbf9e8494, which contains the integer 4
[integer pointer] points to 0xbf9e8498, which contains the integer 5
[char pointer] points to 0xbf9e849f, which contains the char 'a'
[char pointer] points to 0xbf9e84a0, which contains the char 'b'
[char pointer] points to 0xbf9e84a1, which contains the char 'c'
[char pointer] points to 0xbf9e84a2, which contains the char 'd'
[char pointer] points to 0xbf9e84a3, which contains the char 'e'
root@kali:~/hacking/booksrc#
```

> Even though the same value of 1 is added to ```int_pointer``` and ```char_pointer``` in their respective loops, the compiler increments the pointer’s addresses by different amounts. Since a char is only 1 byte, the pointer to the next char would naturally also be 1 byte over. But since an integer is 4 bytes, a pointer to the next integer has to be 4 bytes over.

```sh
root@kali:~/hacking/booksrc# cat pointer_types2.c
#include <stdio.h>

int main() {
	int i;

	char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
	int int_array[5] = {1, 2, 3, 4, 5};

	char *char_pointer;
	int *int_pointer;

	char_pointer = int_array; // The char_pointer and int_pointer now
	int_pointer = char_array; // point to incompatable data types

	for(i=0; i < 5; i++) { // iterate through the int array with the int_pointer
		printf("[integer pointer] points to %p, which contains the char '%c'\n",
            int_pointer, *int_pointer);
		int_pointer = int_pointer + 1;
	}

	for(i=0; i < 5; i++) { // iterate through the char array with the char_pointer
		printf("[char pointer] points to %p, which contains the integer %d\n",
            char_pointer, *char_pointer);
		char_pointer = char_pointer + 1;
	}
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc pointer_types2.c -o pointer_types2
pointer_types2.c: In function ‘main’:
pointer_types2.c:12:15: warning: assignment from incompatible pointer type [-Wincompatible-pointer-types]
  char_pointer = int_array; // The char_pointer and int_pointer now
               ^
pointer_types2.c:13:14: warning: assignment from incompatible pointer type [-Wincompatible-pointer-types]
  int_pointer = char_array; // point to incompatable data types
              ^
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# ./pointer_types2
[integer pointer] points to 0xbfab6e1f, which contains the char 'a'
[integer pointer] points to 0xbfab6e23, which contains the char 'e'
[integer pointer] points to 0xbfab6e27, which contains the char '�'
[integer pointer] points to 0xbfab6e2b, which contains the char '�'
[integer pointer] points to 0xbfab6e2f, which contains the char ''
[char pointer] points to 0xbfab6e08, which contains the integer 1
[char pointer] points to 0xbfab6e09, which contains the integer 0
[char pointer] points to 0xbfab6e0a, which contains the integer 0
[char pointer] points to 0xbfab6e0b, which contains the integer 0
[char pointer] points to 0xbfab6e0c, which contains the integer 2
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# cat pointer_types3.c
#include <stdio.h>

int main() {
	int i;

	char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
	int int_array[5] = {1, 2, 3, 4, 5};

	char *char_pointer;
	int *int_pointer;

	char_pointer = (char *) int_array; // Typecast into the
	int_pointer = (int *) char_array;  // pointer's data type

	for(i=0; i < 5; i++) { // iterate through the int array with the int_pointer
		printf("[integer pointer] points to %p, which contains the char '%c'\n",
            int_pointer, *int_pointer);
		int_pointer = (int *) ((char *) int_pointer + 1);
	}

	for(i=0; i < 5; i++) { // iterate through the char array with the char_pointer
		printf("[char pointer] points to %p, which contains the integer %d\n",
            char_pointer, *char_pointer);
		char_pointer = (char *) ((int *) char_pointer + 1);
	}
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc pointer_types3.c -o pointer_types3
```

```sh
root@kali:~/hacking/booksrc# ./pointer_types3
[integer pointer] points to 0xbfa71daf, which contains the char 'a'
[integer pointer] points to 0xbfa71db0, which contains the char 'b'
[integer pointer] points to 0xbfa71db1, which contains the char 'c'
[integer pointer] points to 0xbfa71db2, which contains the char 'd'
[integer pointer] points to 0xbfa71db3, which contains the char 'e'
[char pointer] points to 0xbfa71d98, which contains the integer 1
[char pointer] points to 0xbfa71d9c, which contains the integer 2
[char pointer] points to 0xbfa71da0, which contains the integer 3
[char pointer] points to 0xbfa71da4, which contains the integer 4
[char pointer] points to 0xbfa71da8, which contains the integer 5
root@kali:~/hacking/booksrc#
```

_**void pointers - Typeless pointers**_

	- Pointers cannot be dereferenced unless they have a type
	- void pointers must be typecasted before doing pointer arithmetic

```sh
root@kali:~/hacking/booksrc# cat pointer_types4.c
#include <stdio.h>

int main() {
	int i;

	char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
	int int_array[5] = {1, 2, 3, 4, 5};

	void *void_pointer;

	void_pointer = (void *) char_array;

	for(i=0; i < 5; i++) { // iterate through the int array with the int_pointer
		printf("[char pointer] points to %p, which contains the char '%c'\n",
            void_pointer, *((char *) void_pointer));
		void_pointer = (void *) ((char *) void_pointer + 1);
	}

	void_pointer = (void *) int_array;

	for(i=0; i < 5; i++) { // iterate through the int array with the int_pointer
		printf("[integer pointer] points to %p, which contains the integer %d\n",
            void_pointer, *((int *) void_pointer));
		void_pointer = (void *) ((int *) void_pointer + 1);
	}
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc pointer_types4.c -o pointer_types4
```

```sh
root@kali:~/hacking/booksrc# ./pointer_types4
[char pointer] points to 0xbf901e93, which contains the char 'a'
[char pointer] points to 0xbf901e94, which contains the char 'b'
[char pointer] points to 0xbf901e95, which contains the char 'c'
[char pointer] points to 0xbf901e96, which contains the char 'd'
[char pointer] points to 0xbf901e97, which contains the char 'e'
[integer pointer] points to 0xbf901e7c, which contains the integer 1
[integer pointer] points to 0xbf901e80, which contains the integer 2
[integer pointer] points to 0xbf901e84, which contains the integer 3
[integer pointer] points to 0xbf901e88, which contains the integer 4
[integer pointer] points to 0xbf901e8c, which contains the integer 5
root@kali:~/hacking/booksrc#
```

> The void pointer is really just holding the memory addresses, while the hard-coded typecasting is telling the compiler to use the proper types whenever the pointer is used.

```sh
root@kali:~/hacking/booksrc# cat pointer_types5.c
#include <stdio.h>

int main() {
	int i;

	char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
	int int_array[5] = {1, 2, 3, 4, 5};

	unsigned int hacky_nonpointer;

	hacky_nonpointer = (unsigned int) char_array;

	for(i=0; i < 5; i++) { // iterate through the int array with the int_pointer
		printf("[hacky_nonpointer] points to %p, which contains the char '%c'\n",
            hacky_nonpointer, *((char *) hacky_nonpointer));
		hacky_nonpointer = hacky_nonpointer + sizeof(char);
	}

	hacky_nonpointer = (unsigned int) int_array;

	for(i=0; i < 5; i++) { // iterate through the int array with the int_pointer
		printf("[hacky_nonpointer] points to %p, which contains the integer %d\n",
            hacky_nonpointer, *((int *) hacky_nonpointer));
		hacky_nonpointer = hacky_nonpointer + sizeof(int);
	}
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc pointer_types5.c -o pointer_types5
```

```sh
root@kali:~/hacking/booksrc# ./pointer_types5
[hacky_nonpointer] points to 0xbfb1f193, which contains the char 'a'
[hacky_nonpointer] points to 0xbfb1f194, which contains the char 'b'
[hacky_nonpointer] points to 0xbfb1f195, which contains the char 'c'
[hacky_nonpointer] points to 0xbfb1f196, which contains the char 'd'
[hacky_nonpointer] points to 0xbfb1f197, which contains the char 'e'
[hacky_nonpointer] points to 0xbfb1f17c, which contains the integer 1
[hacky_nonpointer] points to 0xbfb1f180, which contains the integer 2
[hacky_nonpointer] points to 0xbfb1f184, which contains the integer 3
[hacky_nonpointer] points to 0xbfb1f188, which contains the integer 4
[hacky_nonpointer] points to 0xbfb1f18c, which contains the integer 5
root@kali:~/hacking/booksrc#
```

- Command Line Arguments

```argc``` - argument count

```argv``` - argument vector

```sh
root@kali:~/hacking/booksrc# cat commandline.c
#include <stdio.h>

int main(int arg_count, char *arg_list[]) {
   int i;
   printf("There were %d arguments provided:\n", arg_count);
   for(i=0; i < arg_count; i++)
      printf("argument #%d\t-\t%s\n", i, arg_list[i]);
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc commandline.c -o commandline
```

```sh
root@kali:~/hacking/booksrc# ./commandline
There were 1 arguments provided:
argument #0	-	./commandline
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# ./commandline 1 2 3
There were 4 arguments provided:
argument #0	-	./commandline
argument #1	-	1
argument #2	-	2
argument #3	-	3
root@kali:~/hacking/booksrc#
```

Arguments are treated as strings

Use ```atoi()``` to convert strings to integers

```sh
root@kali:~/hacking/booksrc# cat convert.c
#include <stdio.h>

void usage(char *program_name) {
   printf("Usage: %s <message> <# of times to repeat>\n", program_name);
   exit(1);
}

int main(int argc, char *argv[]) {
   int i, count;

   if(argc < 3)      // If less than 3 arguments are used,
      usage(argv[0]); // display usage message and exit.

   count = atoi(argv[2]); // convert the 2nd arg into an integer
   printf("Repeating %d times..\n", count);

   for(i=0; i < count; i++)
      printf("%3d - %s\n", i, argv[1]); // print the 1st arg
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc convert.c -o convert
convert.c: In function ‘usage’:
convert.c:5:4: warning: implicit declaration of function ‘exit’ [-Wimplicit-function-declaration]
    exit(1);
    ^~~~
convert.c:5:4: warning: incompatible implicit declaration of built-in function ‘exit’
convert.c:5:4: note: include ‘<stdlib.h>’ or provide a declaration of ‘exit’
convert.c: In function ‘main’:
convert.c:14:12: warning: implicit declaration of function ‘atoi’ [-Wimplicit-function-declaration]
    count = atoi(argv[2]); // convert the 2nd arg into an integer
            ^~~~
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# ./convert
Usage: ./convert <message> <# of times to repeat>
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# ./convert Hi 7
Repeating 7 times..
  0 - Hi
  1 - Hi
  2 - Hi
  3 - Hi
  4 - Hi
  5 - Hi
  6 - Hi
root@kali:~/hacking/booksrc#
```

If the program tries to access memory that doesn’t exist or that the program doesn’t have permission to read, the program will crash.

```sh
root@kali:~/hacking/booksrc# cat convert2.c
#include <stdio.h>

void usage(char *program_name) {
   printf("Usage: %s <message> <# of times to repeat>\n", program_name);
   exit(1);
}

int main(int argc, char *argv[]) {
   int i, count;

//  if(argc < 3)      // If less than 3 arguments are used,
//    usage(argv[0]); // display usage message and exit.

   count = atoi(argv[2]); // convert the 2nd arg into an integer
   printf("Repeating %d times..\n", count);

   for(i=0; i < count; i++)
      printf("%3d - %s\n", i, argv[1]); // print the 1st arg
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc convert2.c -o convert2
convert2.c: In function ‘usage’:
convert2.c:5:4: warning: implicit declaration of function ‘exit’ [-Wimplicit-function-declaration]
    exit(1);
    ^~~~
convert2.c:5:4: warning: incompatible implicit declaration of built-in function ‘exit’
convert2.c:5:4: note: include ‘<stdlib.h>’ or provide a declaration of ‘exit’
convert2.c: In function ‘main’:
convert2.c:14:12: warning: implicit declaration of function ‘atoi’ [-Wimplicit-function-declaration]
    count = atoi(argv[2]); // convert the 2nd arg into an integer
            ^~~~
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# ./convert2
Repeating 0 times..
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# ./convert2 sjhdfg 4
Repeating 4 times..
  0 - sjhdfg
  1 - sjhdfg
  2 - sjhdfg
  3 - sjhdfg
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# ./convert2 test
Segmentation fault
root@kali:~/hacking/booksrc#
```

> Memory is split into segments and some memory addresses aren’t within the boundaries of the memory segments the program is given access to. 
> When the program attempts to access an address that is out of bounds, it will crash and die in what’s called a segmentation fault.

```sh
root@kali:~/hacking/booksrc# gcc convert2.c -o convert2_debug -g
convert2.c: In function ‘usage’:
convert2.c:5:4: warning: implicit declaration of function ‘exit’ [-Wimplicit-function-declaration]
    exit(1);
    ^~~~
convert2.c:5:4: warning: incompatible implicit declaration of built-in function ‘exit’
convert2.c:5:4: note: include ‘<stdlib.h>’ or provide a declaration of ‘exit’
convert2.c: In function ‘main’:
convert2.c:14:12: warning: implicit declaration of function ‘atoi’ [-Wimplicit-function-declaration]
    count = atoi(argv[2]); // convert the 2nd arg into an integer
            ^~~~
root@kali:~/hacking/booksrc#
```

Examine the command line arguments using ```GDB```

```sh
root@kali:~/hacking/booksrc# gdb ./convert2_debug -q
Reading symbols from ./convert2_debug...done.
(gdb) run test
Starting program: /root/hacking/booksrc/convert2_debug test

Program received signal SIGSEGV, Segmentation fault.
0xb7e2de54 in __GI_____strtol_l_internal (nptr=0x0, endptr=0x0, base=10, group=0,
    loc=0xb7fb1c20 <_nl_global_locale>) at strtol_l.c:293
293	strtol_l.c: No such file or directory.
(gdb) where
#0  0xb7e2de54 in __GI_____strtol_l_internal (nptr=0x0, endptr=0x0, base=10, group=0,
    loc=0xb7fb1c20 <_nl_global_locale>) at strtol_l.c:293
#1  0xb7e2dcd9 in __strtol (nptr=0x0, endptr=0x0, base=10) at strtol.c:106
#2  0xb7e2b0e0 in atoi (nptr=0x0) at atoi.c:27
#3  0x80000652 in main (argc=2, argv=0xbffff704) at convert2.c:14
(gdb) break main
Breakpoint 1 at 0x80000641: file convert2.c, line 14.
(gdb) run test
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /root/hacking/booksrc/convert2_debug test

Breakpoint 1, main (argc=2, argv=0xbffff704) at convert2.c:14
14	   count = atoi(argv[2]); // convert the 2nd arg into an integer
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0xb7e2de54 in __GI_____strtol_l_internal (nptr=0x0, endptr=0x0, base=10, group=0,
    loc=0xb7fb1c20 <_nl_global_locale>) at strtol_l.c:293
293	strtol_l.c: No such file or directory.
(gdb) x/3xw 0xbffff704
0xbffff704:	0xbffff824	0xbffff849	0x00000000
(gdb) x/s 0xbffff824
0xbffff824:	"/root/hacking/booksrc/convert2_debug"
(gdb) x/s 0xbffff849
0xbffff849:	"test"
(gdb) x/s 0x00000000
0x0:	<error: Cannot access memory at address 0x0>
(gdb) quit
A debugging session is active.

	Inferior 1 [process 2685] will be killed.

Quit anyway? (y or n) y
root@kali:~/hacking/booksrc#
```

- Variable Scoping

```sh
root@kali:~/hacking/booksrc# cat scope.c
#include <stdio.h>

void func3() {
   int i = 11;
   printf("\t\t\t[in func3] i = %d\n", i);
}

void func2() {
   int i = 7;
   printf("\t\t[in func2] i = %d\n", i);
   func3();
   printf("\t\t[back in func2] i = %d\n", i);
}

void func1() {
   int i = 5;
   printf("\t[in func1] i = %d\n", i);
   func2();
   printf("\t[back in func1] i = %d\n", i);
}

int main() {
   int i = 3;
   printf("[in main] i = %d\n", i);
   func1();
   printf("[back in main] i = %d\n", i);
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc scope.c -o scope
```

```sh
root@kali:~/hacking/booksrc# ./scope
[in main] i = 3
	[in func1] i = 5
		[in func2] i = 7
			[in func3] i = 11
		[back in func2] i = 7
	[back in func1] i = 5
[back in main] i = 3
root@kali:~/hacking/booksrc#
```

Global Variable

```sh
root@kali:~/hacking/booksrc# cat scope2.c
#include <stdio.h>

int j = 42; // j is a global variable

void func3() {
   int i = 11, j = 999; // here, j is a local variable of func3()
   printf("\t\t\t[in func3] i = %d, j = %d\n", i, j);
}

void func2() {
   int i = 7;
   printf("\t\t[in func2] i = %d, j = %d\n", i, j);
   printf("\t\t[in func2] setting j = 1337\n");
   j = 1337; // writing to j
   func3();
   printf("\t\t[back in func2] i = %d, j = %d\n", i, j);
}

void func1() {
   int i = 5;
   printf("\t[in func1] i = %d, j = %d\n", i, j);
   func2();
   printf("\t[back in func1] i = %d, j = %d\n", i, j);
}

int main() {
   int i = 3;
   printf("[in main] i = %d, j = %d\n", i, j);
   func1();
   printf("[back in main] i = %d, j = %d\n", i, j);
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc scope2.c -o scope2
```

```sh
root@kali:~/hacking/booksrc# ./scope2
[in main] i = 3, j = 42
	[in func1] i = 5, j = 42
		[in func2] i = 7, j = 42
		[in func2] setting j = 1337
			[in func3] i = 11, j = 999
		[back in func2] i = 7, j = 1337
	[back in func1] i = 5, j = 1337
[back in main] i = 3, j = 1337
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# cat scope3.c
#include <stdio.h>

int j = 42; // j is a global variable

void func3() {
   int i = 11, j = 999; // here, j is a local variable of func3()
   printf("\t\t\t[in func3] i @ 0x%08x = %d\n", &i, i);
   printf("\t\t\t[in func3] j @ 0x%08x = %d\n", &j, j);
}

void func2() {
   int i = 7;
   printf("\t\t[in func2] i @ 0x%08x = %d\n", &i, i);
   printf("\t\t[in func2] j @ 0x%08x = %d\n", &j, j);
   printf("\t\t[in func2] setting j = 1337\n");
   j = 1337; // writing to j
   func3();
   printf("\t\t[back in func2] i @ 0x%08x = %d\n", &i, i);
   printf("\t\t[back in func2] j @ 0x%08x = %d\n", &j, j);
}

void func1() {
   int i = 5;
   printf("\t[in func1] i @ 0x%08x = %d\n", &i, i);
   printf("\t[in func1] j @ 0x%08x = %d\n", &j, j);
   func2();
   printf("\t[back in func1] i @ 0x%08x = %d\n", &i, i);
   printf("\t[back in func1] j @ 0x%08x = %d\n", &j, j);
}

int main() {
   int i = 3;
   printf("[in main] i @ 0x%08x = %d\n", &i, i);
   printf("[in main] j @ 0x%08x = %d\n", &j, j);
   func1();
   printf("[back in main] i @ 0x%08x = %d\n", &i, i);
   printf("[back in main] j @ 0x%08x = %d\n", &j, j);
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc scope3.c -o scope3
```

```sh
root@kali:~/hacking/booksrc# ./scope3
[in main] i @ 0xbfadb68c = 3
[in main] j @ 0x80032020 = 42
	[in func1] i @ 0xbfadb66c = 5
	[in func1] j @ 0x80032020 = 42
		[in func2] i @ 0xbfadb64c = 7
		[in func2] j @ 0x80032020 = 42
		[in func2] setting j = 1337
			[in func3] i @ 0xbfadb62c = 11
			[in func3] j @ 0xbfadb628 = 999
		[back in func2] i @ 0xbfadb64c = 7
		[back in func2] j @ 0x80032020 = 1337
	[back in func1] i @ 0xbfadb66c = 5
	[back in func1] j @ 0x80032020 = 1337
[back in main] i @ 0xbfadb68c = 3
[back in main] j @ 0x80032020 = 1337
root@kali:~/hacking/booksrc#
```
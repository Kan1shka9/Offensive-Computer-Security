#### 0x200 Programming

```Assembly language``` ----Assembler----&rightarrow; ```Machine language```

```High-level language``` ----Compiler----&rightarrow; ```Machine language```

###### Pseudo-code

- English like 
- Arranged with a general structure 
- Similar to a high-level language

###### Control Structures

- If-Then-Else

```
If (condition) then 
{	Set of instructions to execute if the condition is met;} 
Else 
{	Set of instruction to execute if the condition is not met;}
```

- While/Until Loops

```
While (you are hungry) 
{	Find some food;	Eat the food; 
}
```

```
Until (you are not hungry) 
{	Find some food;	Eat the food; 
}
```

- For Loops

```
for (i=0; i<5; i++)
{
	Drive straight for 1 mile;
}
```

###### More Fundamental Programming Concepts

- Variables
	- Variables
	- Constants

```
int a, b; 
float k; 
char z;
```

```
int a = 13, b; 
float k;char z = 'A';
k = 3.14; 
z = 'w';b = a + 5;
```

- Arithmetic Operators

Operation | Symbol | Example
----------|--------|---------Addition 	| + | b = a + 5
Subtraction | - | b = a - 5
Multiplication | * | b = a * 5
Division | / | b = a / 5Modulo reduction | % | b = a % 5Full Expression | Shorthand | Explanation
----------------|-----------|-----------------
i = i + 1 | i++ or ++i | Add 1 to the variable
i = i - 1 | i-- or --i | Subtract 1 from the variable

Full Expression | Shorthand | Explanation
----------------|-----------|-----------------
i = i + 12 | i+=12 | Add some value to the variable.
i = i - 12 | i-=12 | Subtract some value from the variable.
i = i * 12 | i*=12 | Multiply some value by the variable.
i = i / 12 | i/=12 | Divide some value from the variable.

- Comparison Operators

Condition | Symbol | Example
----------|--------|-------------
Less than | < | (a<b)
Greater than | > | (a>b)
Less than or equal to | <= | (a<=b)
Greater than or equal to | >= | (a>=b)
Equal to | == | (a==b)
Not equal to | != | (a!=b)

Logic | Symbol | Example
------|--------|-------------
OR | ```||``` | ((a < b) || (a < c))
AND | ```&&``` | ((a < b) && !(a < c))

- Functions

```
int factorial(int x) 
{	int i;	for(i=1; i < x; i++)    	x *= i;  	return x;}```

```
int a = 5, b;b = factorial(a);
```

```
int factorial(int);
```

###### Getting your hands dirty

- Location of header files

```/usr/include```

- ```GCC``` Version

```sh
root@kali:~/hacking/booksrc# gcc --version
gcc (Debian 6.3.0-12) 6.3.0 20170406
Copyright (C) 2016 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

root@kali:~/hacking/booksrc#
```

- Write and Compile ```C``` programs

```sh
root@kali:~/hacking/booksrc# cat firstprog.c
#include <stdio.h>

int main()
{
  int i;
  for(i=0; i < 10; i++)
  {
    printf("Hello World!\n");
  }
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc firstprog.c -o firstprog
```

```sh
root@kali:~/hacking/booksrc# file firstprog
firstprog: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=84d59dc5f956badc162523dcaa2dc18e0fe5be5a, not stripped
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# ./firstprog
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
root@kali:~/hacking/booksrc#
```

- Machine code of the ```main()``` function

	- AT&T

	```sh
	root@kali:~/hacking/booksrc# objdump -D firstprog | grep -A 36 main.:
	00000590 <main>:
	 590:	8d 4c 24 04          	lea    0x4(%esp),%ecx
	 594:	83 e4 f0             	and    $0xfffffff0,%esp
	 597:	ff 71 fc             	pushl  -0x4(%ecx)
	 59a:	55                   	push   %ebp
	 59b:	89 e5                	mov    %esp,%ebp
	 59d:	53                   	push   %ebx
	 59e:	51                   	push   %ecx
	 59f:	83 ec 10             	sub    $0x10,%esp
	 5a2:	e8 b9 fe ff ff       	call   460 <__x86.get_pc_thunk.bx>
	 5a7:	81 c3 59 1a 00 00    	add    $0x1a59,%ebx
	 5ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	 5b4:	eb 16                	jmp    5cc <main+0x3c>
	 5b6:	83 ec 0c             	sub    $0xc,%esp
	 5b9:	8d 83 70 e6 ff ff    	lea    -0x1990(%ebx),%eax
	 5bf:	50                   	push   %eax
	 5c0:	e8 2b fe ff ff       	call   3f0 <puts@plt>
	 5c5:	83 c4 10             	add    $0x10,%esp
	 5c8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
	 5cc:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
	 5d0:	7e e4                	jle    5b6 <main+0x26>
	 5d2:	b8 00 00 00 00       	mov    $0x0,%eax
	 5d7:	8d 65 f8             	lea    -0x8(%ebp),%esp
	 5da:	59                   	pop    %ecx
	 5db:	5b                   	pop    %ebx
	 5dc:	5d                   	pop    %ebp
	 5dd:	8d 61 fc             	lea    -0x4(%ecx),%esp
	 5e0:	c3                   	ret
	 5e1:	66 90                	xchg   %ax,%ax
	 5e3:	66 90                	xchg   %ax,%ax
	 5e5:	66 90                	xchg   %ax,%ax
	 5e7:	66 90                	xchg   %ax,%ax
	 5e9:	66 90                	xchg   %ax,%ax
	 5eb:	66 90                	xchg   %ax,%ax
	 5ed:	66 90                	xchg   %ax,%ax
	 5ef:	90                   	nop
	
	root@kali:~/hacking/booksrc#
	```

	- Intel

	```sh
	root@kali:~/hacking/booksrc# objdump -D firstprog -M intel | grep -A 36 main.:
	00000590 <main>:
	 590:	8d 4c 24 04          	lea    ecx,[esp+0x4]
	 594:	83 e4 f0             	and    esp,0xfffffff0
	 597:	ff 71 fc             	push   DWORD PTR [ecx-0x4]
	 59a:	55                   	push   ebp
	 59b:	89 e5                	mov    ebp,esp
	 59d:	53                   	push   ebx
	 59e:	51                   	push   ecx
	 59f:	83 ec 10             	sub    esp,0x10
	 5a2:	e8 b9 fe ff ff       	call   460 <__x86.get_pc_thunk.bx>
	 5a7:	81 c3 59 1a 00 00    	add    ebx,0x1a59
	 5ad:	c7 45 f4 00 00 00 00 	mov    DWORD PTR [ebp-0xc],0x0
	 5b4:	eb 16                	jmp    5cc <main+0x3c>
	 5b6:	83 ec 0c             	sub    esp,0xc
	 5b9:	8d 83 70 e6 ff ff    	lea    eax,[ebx-0x1990]
	 5bf:	50                   	push   eax
	 5c0:	e8 2b fe ff ff       	call   3f0 <puts@plt>
	 5c5:	83 c4 10             	add    esp,0x10
	 5c8:	83 45 f4 01          	add    DWORD PTR [ebp-0xc],0x1
	 5cc:	83 7d f4 09          	cmp    DWORD PTR [ebp-0xc],0x9
	 5d0:	7e e4                	jle    5b6 <main+0x26>
	 5d2:	b8 00 00 00 00       	mov    eax,0x0
	 5d7:	8d 65 f8             	lea    esp,[ebp-0x8]
	 5da:	59                   	pop    ecx
	 5db:	5b                   	pop    ebx
	 5dc:	5d                   	pop    ebp
	 5dd:	8d 61 fc             	lea    esp,[ecx-0x4]
	 5e0:	c3                   	ret
	 5e1:	66 90                	xchg   ax,ax
	 5e3:	66 90                	xchg   ax,ax
	 5e5:	66 90                	xchg   ax,ax
	 5e7:	66 90                	xchg   ax,ax
	 5e9:	66 90                	xchg   ax,ax
	 5eb:	66 90                	xchg   ax,ax
	 5ed:	66 90                	xchg   ax,ax
	 5ef:	90                   	nop
	
	root@kali:~/hacking/booksrc#
	```
	
###### The x86 Processor

- Registers
	- Internal Variables

General Purpose Register | Use
-------------------------|--------
EAX | Accumulator
EBX | Base
ECX | Counter
EDX | Data

Pointers & Indexes | Use
-------------------|------
ESP | Stack Pointer
EBP | Base Pointer
ESI | Source Index
EDI | Destination Index

```EIP```
	- Instruction Pointer
	- Points to the current instruction the processor is reading

[```EFLAGS```](http://www.c-jump.com/CIS77/ASM/Instructions/I77_0070_eflags_bits.htm)
	- Bit flags that are used for comparisons and memory segmentation


- Debugger
	- Step through the compiled program
	- Examine program memory
	- View processor registers

- GDB

```sh
root@kali:~/hacking/booksrc# gdb ./firstprog -q
Reading symbols from ./firstprog...(no debugging symbols found)...done.
(gdb) break main
Breakpoint 1 at 0x59f
(gdb) run
Starting program: /root/hacking/booksrc/firstprog

Breakpoint 1, 0x8000059f in main ()
(gdb) info registers
eax            0xb7fb2dbc	-1208275524
ecx            0xbffff680	-1073744256
edx            0xbffff6a4	-1073744220
ebx            0x0	0
esp            0xbffff660	0xbffff660
ebp            0xbffff668	0xbffff668
esi            0x1	1
edi            0xb7fb1000	-1208283136
eip            0x8000059f	0x8000059f <main+15>
eflags         0x282	[ SF IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb) quit
A debugging session is active.

	Inferior 1 [process 1605] will be killed.

Quit anyway? (y or n) y
root@kali:~/hacking/booksrc#
```

###### Assembly Language

- ```GDB``` init file to use ```Intel``` syntax

```sh
root@kali:~/hacking/booksrc# gdb -q
(gdb) set disassembly-flavor intel
(gdb) quit
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# echo "set disassembly-flavor intel" > ~/.gdbinit
root@kali:~/hacking/booksrc# cat ~/.gdbinit
set disassembly-flavor intel
root@kali:~/hacking/booksrc#
```

- Intel Syntax

```
operation <destination>, <source>
```

```DWORD``` - 4 bytes

- Compile with debug information

```sh
root@kali:~/hacking/booksrc# gcc firstprog.c -o firstprog_debug -g
```

```sh
root@kali:~/hacking/booksrc# file firstprog_debug
firstprog_debug: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=f9594a9b7afa7598a838fee6af6531982c357267, not stripped
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gdb ./firstprog_debug -q
Reading symbols from ./firstprog_debug...done.
(gdb) list
1	#include <stdio.h>
2
3	int main()
4	{
5	  int i;
6	  for(i=0; i < 10; i++)
7	  {
8	    printf("Hello World!\n");
9	  }
10	}
(gdb) disassemble main
Dump of assembler code for function main:
   0x00000590 <+0>:	lea    ecx,[esp+0x4]
   0x00000594 <+4>:	and    esp,0xfffffff0
   0x00000597 <+7>:	push   DWORD PTR [ecx-0x4]
   0x0000059a <+10>:	push   ebp
   0x0000059b <+11>:	mov    ebp,esp
   0x0000059d <+13>:	push   ebx
   0x0000059e <+14>:	push   ecx
   0x0000059f <+15>:	sub    esp,0x10
   0x000005a2 <+18>:	call   0x460 <__x86.get_pc_thunk.bx>
   0x000005a7 <+23>:	add    ebx,0x1a59
   0x000005ad <+29>:	mov    DWORD PTR [ebp-0xc],0x0
   0x000005b4 <+36>:	jmp    0x5cc <main+60>
   0x000005b6 <+38>:	sub    esp,0xc
   0x000005b9 <+41>:	lea    eax,[ebx-0x1990]
   0x000005bf <+47>:	push   eax
   0x000005c0 <+48>:	call   0x3f0 <puts@plt>
   0x000005c5 <+53>:	add    esp,0x10
   0x000005c8 <+56>:	add    DWORD PTR [ebp-0xc],0x1
   0x000005cc <+60>:	cmp    DWORD PTR [ebp-0xc],0x9
   0x000005d0 <+64>:	jle    0x5b6 <main+38>
   0x000005d2 <+66>:	mov    eax,0x0
   0x000005d7 <+71>:	lea    esp,[ebp-0x8]
   0x000005da <+74>:	pop    ecx
   0x000005db <+75>:	pop    ebx
   0x000005dc <+76>:	pop    ebp
   0x000005dd <+77>:	lea    esp,[ecx-0x4]
   0x000005e0 <+80>:	ret
End of assembler dump.
(gdb) break main
Breakpoint 1 at 0x5ad: file firstprog.c, line 6.
(gdb) run
Starting program: /root/hacking/booksrc/firstprog_debug

Breakpoint 1, main () at firstprog.c:6
6	  for(i=0; i < 10; i++)
(gdb) info registers eip
eip            0x800005ad	0x800005ad <main+29>
(gdb)
```

EIP

```sh
   0x000005ad <+29>:	mov    DWORD PTR [ebp-0xc],0x0
```

Function Prolog

```sh
   0x00000590 <+0>:		lea    ecx,[esp+0x4]
   0x00000594 <+4>:		and    esp,0xfffffff0
   0x00000597 <+7>:		push   DWORD PTR [ecx-0x4]
   0x0000059a <+10>:	push   ebp
   0x0000059b <+11>:	mov    ebp,esp
   0x0000059d <+13>:	push   ebx
   0x0000059e <+14>:	push   ecx
   0x0000059f <+15>:	sub    esp,0x10
   0x000005a2 <+18>:	call   0x460 <__x86.get_pc_thunk.bx>
   0x000005a7 <+23>:	add    ebx,0x1a59
```

- Examine - ```x```
	- 2 arguments
		- Location of memory to examine
		- How to display the memory
			- display is preceded by a count of how many items to examine

Display format Shorthand | Display format
-------------------------|------------------
o | Octal
x | hexadecimal
u | unsigned, standard base-10 decimal
t | binary
c | character
s | entire string

```sh
(gdb) i r eip
eip            0x800005ad	0x800005ad <main+29>
(gdb) x/o 0x800005ad
0x800005ad <main+29>:	075042707
(gdb) x/x 0x800005ad
0x800005ad <main+29>:	0x00f445c7
(gdb) x/u 0x800005ad
0x800005ad <main+29>:	16008647
(gdb) x/t 0x800005ad
0x800005ad <main+29>:	00000000111101000100010111000111
(gdb)
```

```sh
(gdb) x/2x $eip
0x800005ad <main+29>:	0x00f445c7	0xeb000000
(gdb) x/12x $eip
0x800005ad <main+29>:	0x00f445c7	0xeb000000	0x0cec8316	0xe670838d
0x800005bd <main+45>:	0xe850ffff	0xfffffe2b	0x8310c483	0x8301f445
0x800005cd <main+61>:	0x7e09f47d	0x0000b8e4	0x658d0000	0x5d5b59f8
(gdb)
```

Size Alphabet | Size
--------------|--------
b | 1 byte
h | Halfword - 2 bytes
w | Word - 4 bytes
g | Giant - 8 bytes

_**Sometimes ```DWORD``` and ```WORD``` both are 4 bytes**_


```sh
(gdb) x/8xb $eip
0x800005ad <main+29>:	0xc7	0x45	0xf4	0x00	0x00	0x00	0x00	0xeb
(gdb) x/8xh $eip
0x800005ad <main+29>:	0x45c7	0x00f4	0x0000	0xeb00	0x8316	0x0cec	0x838d	0xe670
(gdb) x/8xw $eip
0x800005ad <main+29>:	0x00f445c7	0xeb000000	0x0cec8316	0xe670838d
0x800005bd <main+45>:	0xe850ffff	0xfffffe2b	0x8310c483	0x8301f445
(gdb) x/8xg $eip
0x800005ad <main+29>:	0xeb00000000f445c7	0xe670838d0cec8316
0x800005bd <main+45>:	0xfffffe2be850ffff	0x8301f4458310c483
0x800005cd <main+61>:	0x0000b8e47e09f47d	0x5d5b59f8658d0000
0x800005dd <main+77>:	0x90669066c3fc618d	0x9066906690669066
(gdb)
```

Examine instructions - ```i```

```sh
root@kali:~/hacking/booksrc# gdb ./firstprog_debug -q
Reading symbols from ./firstprog_debug...done.
(gdb) break main
Breakpoint 1 at 0x5ad: file firstprog.c, line 6.
(gdb) run
Starting program: /root/hacking/booksrc/firstprog_debug

Breakpoint 1, main () at firstprog.c:6
6	  for(i=0; i < 10; i++)
(gdb) i r $eip
eip            0x800005ad	0x800005ad <main+29>
(gdb) x/i $eip
=> 0x800005ad <main+29>:	mov    DWORD PTR [ebp-0xc],0x0
(gdb) x/3i $eip
=> 0x800005ad <main+29>:	mov    DWORD PTR [ebp-0xc],0x0
   0x800005b4 <main+36>:	jmp    0x800005cc <main+60>
   0x800005b6 <main+38>:	sub    esp,0xc
(gdb) x/7xb $eip
0x800005ad <main+29>:	0xc7	0x45	0xf4	0x00	0x00	0x00	0x00
(gdb) x/i $eip
=> 0x800005ad <main+29>:	mov    DWORD PTR [ebp-0xc],0x0
(gdb)
```

```objdump``` output

```sh
root@kali:~/hacking/booksrc# objdump -D firstprog -M intel | grep -A 36 main.:
<---snip--->
  5ad:	c7 45 f4 00 00 00 00 	mov    DWORD PTR [ebp-0xc],0x0
<---snip--->
```

Examining the ```ebp-0xc```

```sh
(gdb) i r ebp
ebp            0xbffff658	0xbffff658
(gdb) x/4xb $ebp-0xc
0xbffff64c:	0x11	0x06	0x00	0x80
(gdb) x/12xb $ebp-0xc
0xbffff64c:	0x11	0x06	0x00	0x80	0x70	0xf6	0xff	0xbf
0xbffff654:	0x00	0x00	0x00	0x00
(gdb) print $ebp-0xc
$1 = (void *) 0xbffff64c
(gdb) x/4xb $1
0xbffff64c:	0x11	0x06	0x00	0x80
(gdb) x/xw $1
0xbffff64c:	0x80000611
```

Single Step and check the value of ```ebp-0xc```

```sh
(gdb) nexti
0x800005b4	6	  for(i=0; i < 10; i++)
(gdb) x/xw $1
0xbffff64c:	0x00000000
(gdb) x/4xb $1
0xbffff64c:	0x00	0x00	0x00	0x00
(gdb) x/dw $1
0xbffff64c:	0
(gdb) i r eip
eip            0x800005b4	0x800005b4 <main+36>
(gdb) x/i $eip
=> 0x800005b4 <main+36>:	jmp    0x800005cc <main+60>
(gdb)
```

Refer to page ```32``` - ```37``` of the book - Very detailed and nice explanation

###### Back to Basics

- Strings

Refer to page ```38``` - ```41``` of the book

```sh
root@kali:~/hacking/booksrc# cat char_array.c
#include <stdio.h>
int main()
{
  char str_a[20];
  str_a[0]  = 'H';
  str_a[1]  = 'e';
  str_a[2]  = 'l';
  str_a[3]  = 'l';
  str_a[4]  = 'o';
  str_a[5]  = ',';
  str_a[6]  = ' ';
  str_a[7]  = 'w';
  str_a[8]  = 'o';
  str_a[9]  = 'r';
  str_a[10]  = 'l';
  str_a[11] = 'd';
  str_a[12] = '!';
  str_a[13] = '\n';
  str_a[14] = 0;
  printf(str_a);
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc char_array.c -o char_array
```

```sh
root@kali:~/hacking/booksrc# ./char_array
Hello, world!
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# cat char_array2.c
#include <stdio.h>
#include <string.h>

int main() {
   char str_a[20];

   strcpy(str_a, "Hello World!\n");
   printf(str_a);
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc char_array2.c -o char_array2
```

```sh
root@kali:~/hacking/booksrc# ./char_array2
Hello World!
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc char_array2.c -o char_array2_debug -g
```

```sh
root@kali:~/hacking/booksrc# ./char_array2_debug
Hello World!
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gdb ./char_array2_debug -q
Reading symbols from ./char_array2_debug...done.
(gdb) list
1	#include <stdio.h>
2	#include <string.h>
3
4	int main() {
5	   char str_a[20];
6
7	   strcpy(str_a, "Hello World!\n");
8	   printf(str_a);
9	}
(gdb) break 6
Breakpoint 1 at 0x5bd: file char_array2.c, line 6.
(gdb) break strcpy
Function "strcpy" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 2 (strcpy) pending.
(gdb) break 8
Breakpoint 3 at 0x5da: file char_array2.c, line 8.
(gdb) info breakpoints
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x000005bd in main at char_array2.c:6
2       breakpoint     keep y   <PENDING>  strcpy
3       breakpoint     keep y   0x000005da in main at char_array2.c:8
(gdb) run
Starting program: /root/hacking/booksrc/char_array2_debug

Breakpoint 1, main () at char_array2.c:7
7	   strcpy(str_a, "Hello World!\n");
(gdb) i r eip
eip            0x800005bd	0x800005bd <main+29>
(gdb) x/5i $eip
=> 0x800005bd <main+29>:	lea    eax,[ebp-0x1c]
   0x800005c0 <main+32>:	mov    DWORD PTR [eax],0x6c6c6548
   0x800005c6 <main+38>:	mov    DWORD PTR [eax+0x4],0x6f57206f
   0x800005cd <main+45>:	mov    DWORD PTR [eax+0x8],0x21646c72
   0x800005d4 <main+52>:	mov    WORD PTR [eax+0xc],0xa
(gdb) continue
Continuing.

Breakpoint 3, main () at char_array2.c:8
8	   printf(str_a);
(gdb) i r eip
eip            0x800005da	0x800005da <main+58>
(gdb) x/5i $eip
=> 0x800005da <main+58>:	sub    esp,0xc
   0x800005dd <main+61>:	lea    eax,[ebp-0x1c]
   0x800005e0 <main+64>:	push   eax
   0x800005e1 <main+65>:	mov    ebx,edx
   0x800005e3 <main+67>:	call   0x80000400 <printf@plt>
(gdb) c
Continuing.
Hello World!
[Inferior 1 (process 31559) exited normally]
(gdb) q
root@kali:~/hacking/booksrc#
```

```bt``` - backtrace the stack

```sh
root@kali:~/hacking/booksrc# gdb ./char_array2_debug -q
Reading symbols from ./char_array2_debug...done.
(gdb) list
1	#include <stdio.h>
2	#include <string.h>
3
4	int main() {
5	   char str_a[20];
6
7	   strcpy(str_a, "Hello World!\n");
8	   printf(str_a);
9	}
(gdb) b 7
Breakpoint 1 at 0x5bd: file char_array2.c, line 7.
(gdb) b strcpy
Function "strcpy" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 2 (strcpy) pending.
(gdb) b 8
Breakpoint 3 at 0x5da: file char_array2.c, line 8.
(gdb) info breakpoints
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x000005bd in main at char_array2.c:7
2       breakpoint     keep y   <PENDING>  strcpy
3       breakpoint     keep y   0x000005da in main at char_array2.c:8
(gdb) run
Starting program: /root/hacking/booksrc/char_array2_debug

Breakpoint 1, main () at char_array2.c:7
7	   strcpy(str_a, "Hello World!\n");
(gdb) bt
#0  main () at char_array2.c:7
(gdb) c
Continuing.

Breakpoint 3, main () at char_array2.c:8
8	   printf(str_a);
(gdb) bt
#0  main () at char_array2.c:8
(gdb) c
Continuing.
Hello World!
[Inferior 1 (process 31599) exited normally]
(gdb)
```

- Signed, Unsigned, Long, Short

Signed | Representation
-------|-------------
+ve Number | Normal
-ve Number | Two's Complement

Two's Complement Process

+ve Number in binary &rightarrow; invert all bits &rightarrow; add 1

```sh
#include <stdio.h>

int main() {
	printf("The 'int' data type is\t\t %d bytes\n", sizeof(int));
	printf("The 'unsigned int' data type is\t %d bytes\n", sizeof(unsigned int));
	printf("The 'short int' data type is\t %d bytes\n", sizeof(short int));
	printf("The 'long int' data type is\t %d bytes\n", sizeof(long int));
	printf("The 'long long int' data type is %d bytes\n", sizeof(long long int));
	printf("The 'float' data type is\t %d bytes\n", sizeof(float));
	printf("The 'char' data type is\t\t %d bytes\n", sizeof(char));
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc datatype_sizes.c -o datatype_sizes
```

```sh
root@kali:~/hacking/booksrc# ./datatype_sizes
The 'int' data type is		 4 bytes
The 'unsigned int' data type is	 4 bytes
The 'short int' data type is	 2 bytes
The 'long int' data type is	 4 bytes
The 'long long int' data type is 8 bytes
The 'float' data type is	 4 bytes
The 'char' data type is		 1 bytes
root@kali:~/hacking/booksrc#
```

- Pointer

```sh
root@kali:~/hacking/booksrc# cat pointer.c
#include <stdio.h>
#include <string.h>

int main() {
   char str_a[20];  // a 20 element character array
   char *pointer;   // a pointer, meant for a character array
   char *pointer2;  // and yet another one

   strcpy(str_a, "Hello World\n");
   pointer = str_a; // set the first pointer to the start of the array
   printf(pointer);

   pointer2 = pointer + 2; // set the second one 2 bytes further in
   printf(pointer2);       // print it
   strcpy(pointer2, "y you guys!\n"); // copy into that spot
   printf(pointer);        // print again
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc pointer.c -o pointer
```

```sh
root@kali:~/hacking/booksrc# ./pointer
Hello World
llo World
Hey you guys!
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gdb ./pointer_debug -q
Reading symbols from ./pointer_debug...done.
(gdb) list
1	#include <stdio.h>
2	#include <string.h>
3
4	int main() {
5	   char str_a[20];  // a 20 element character array
6	   char *pointer;   // a pointer, meant for a character array
7	   char *pointer2;  // and yet another one
8
9	   strcpy(str_a, "Hello World\n");
10	   pointer = str_a; // set the first pointer to the start of the array
(gdb)
11	   printf(pointer);
12
13	   pointer2 = pointer + 2; // set the second one 2 bytes further in
14	   printf(pointer2);       // print it
15	   strcpy(pointer2, "y you guys!\n"); // copy into that spot
16	   printf(pointer);        // print again
17	}
(gdb) break 11
Breakpoint 1 at 0x5de: file pointer.c, line 11.
(gdb) run
Starting program: /root/hacking/booksrc/pointer_debug

Breakpoint 1, main () at pointer.c:11
11	   printf(pointer);
(gdb) x/xw pointer
0xbffff624:	0x6c6c6548
(gdb) x/s pointer
0xbffff624:	"Hello World\n"
(gdb)
```

Pointer Operations | Descriptions
-------------------|--------------------------------------
&pointer | Return the address of the ```pointer``` variable
pointer  | Value (usually an address as pointer variables store an address)
*pointer | Value stored in the address stored at ```pointer```(Dereference operator)

```sh
(gdb) x/xw &pointer
0xbffff63c:	0xbffff624
(gdb) print &pointer
$1 = (char **) 0xbffff63c
(gdb) print pointer
$2 = 0xbffff624 "Hello World\n"
(gdb)
```

```sh
root@kali:~/hacking/booksrc# cat addressof.c
#include <stdio.h>

int main() {
	int int_var = 5;
	int *int_ptr;

	int_ptr = &int_var; // put the address of int_var into int_ptr
}
root@kali:~/hacking/booksrc#
```

```sh
root@kali:~/hacking/booksrc# gcc addressof.c -o addressof
```

```sh
root@kali:~/hacking/booksrc# ./addressof
```

```sh
root@kali:~/hacking/booksrc# gcc addressof.c -o addressof_debug -g
```

```sh
root@kali:~/hacking/booksrc# ./addressof_debug
```

```sh
root@kali:~/hacking/booksrc# gdb ./addressof_debug -q
Reading symbols from ./addressof_debug...done.
(gdb) list
1	#include <stdio.h>
2
3	int main() {
4		int int_var = 5;
5		int *int_ptr;
6
7		int_ptr = &int_var; // put the address of int_var into int_ptr
8	}
(gdb) break 8
Breakpoint 1 at 0x582: file addressof.c, line 8.
(gdb) run
Starting program: /root/hacking/booksrc/addressof_debug

Breakpoint 1, main () at addressof.c:8
8	}
(gdb) print int_var
$1 = 5
(gdb) print &int_var
$2 = (int *) 0xbffff650
(gdb) print int_ptr
$3 = (int *) 0xbffff650
(gdb) print &int_ptr
$4 = (int **) 0xbffff654
(gdb) print *int_ptr
$5 = 5
(gdb)
```

```sh
```

```sh
```